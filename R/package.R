##' Update generated code in a package that uses odin and dust to
##' provide a model. This will generate new dust code in `inst/dust`
##' and from that generate a full model in `src`, and an R interface
##' in `R/dust.R`, along with the cpp11 attributes that are needed to
##' use the model.
##'
##' This function is powered by [dust2::dust_package], and the same
##' pre-requisites apply here:
##'
##' For your `DESCRIPTION` file:
##'
##' * `dust2` must be in `Imports`
##' * `cpp11`, `dust2` and `monty` must be in `LinkingTo`
##'
##' For your `NAMESPACE` file:
##'
##' * you must have a suitable `useDynLib()` call with `.registration = TRUE`
##'
##' If you do not satisfy these requirements, `dust2::dust_package`
##' will fail with a message indicating actions you should take.  Once
##' set up, generally things will keep working.
##'
##' If you want your packages to build on GitHub actions, or be
##' installable via `remotes::install_github` you should add to your
##' `DESCRIPTION`:
##'
##' ```
##' Remotes: mrc-ide/dust2, mrc-ide/monty
##' ```
##'
##' Note that you do not need to include odin2 itself as a dependency.
##'
##' @title Update odin code in package
##'
##' @param path Path to the package root (the directory that contains
##'   `DESCRIPTION`), or any path within that package.
##'
##' @inheritParams odin
##'
##' @return Invisibly, the path to the package.  However, this
##'   function is typically called for its side effect of updating
##'   files in `inst/dust` and `src` within this package after you
##'   have changed the odin code in `inst/odin`.
##'
##' @seealso `vignette("packaging")` for more details, and
##'   `dust2::dust_package()`, which does most of the work here.
##'
##' @export
##' @examplesIf requireNamespace("fs", quietly = TRUE)
##' \dontshow{
##' path <- odin2:::example_package()
##' }
##' # An example package structure
##' fs::dir_tree(path)
##'
##' # Generate odin code:
##' odin_package(path)
##'
##' # Resulting files:
##' fs::dir_tree(path)
odin_package <- function(path, quiet = FALSE, compatibility = NULL,
                         check_bounds = NULL) {
  ## This finds the package root, and errors (fairly) nicely if it is
  ## not found.
  path <- pkgload::pkg_path(path)

  header <- sprintf("// Generated by odin2 (version %s) - do not edit",
                    utils::packageVersion("odin2"))
  re_r <- "\\.[Rr]$"
  filenames <- dir(file.path(path, "inst/odin"), re_r, full.names = TRUE)
  n <- length(filenames)
  if (n == 0) {
    cli::cli_abort(
      c("Did not find any odin code in 'inst/odin'",
        i = "Looked in package root at '{path}'"))
  }
  if (!quiet) {
    cli::cli_alert_info("Found {n} odin code file{?s} in 'inst/odin'")
  }

  ## The default base name for the C++ class:
  base <- sub(re_r, "", basename(filenames))

  dest_rel <- file.path("inst/dust", paste0(base, ".cpp"))
  dest_abs <- file.path(path, dest_rel)
  dest_exists <- file.exists(dest_abs)
  if (any(dest_exists)) {
    err <- !vlapply(dest_abs[dest_exists], function(p) {
      txt <- readLines(p, n = 1)
      length(txt) == 1 && grepl("^//+ Generated by odin.*do not edit$", txt)
    })
    if (any(err)) {
      err_path <- dest_rel[dest_exists][err]
      cli::cli_abort(
        c("Refusing to overwrite file not generated by odin2",
          x = "{squote(err_path)} {?looks/look} hand-written",
          i = "Looked in package root at '{path}'",
          i = paste("If this error is unwanted, please delete these files",
                    "manually and try again")))
    }
  }

  ## Process everything before writing anything:
  dat <- lapply(filenames, odin_parse,
                compatibility = compatibility,
                check_bounds = check_bounds,
                input_type = "file")
  ## For now, take the base name of the input .R file as the class
  ## name for the generated C++ code; we'll make this configurable
  ## once we support a general approach for config/options.
  for (i in seq_along(dat)) {
    dat[[i]]$class <- gsub("-", "_", base[[i]], fixed = TRUE)
  }
  ## We still fail quite a lot during generation, so let's do that all
  ## at once too:
  code <- lapply(dat, generate_dust_system)

  dir_create(file.path(path, "inst/dust"))
  for (i in seq_along(code)) {
    writelines_if_changed(c(header, code[[i]]), path, dest_rel[[i]],
                          quiet = quiet)
  }

  dust2::dust_package(path, quiet = quiet)

  invisible(path)
}
